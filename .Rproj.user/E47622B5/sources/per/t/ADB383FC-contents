---
title: "EDA"
author: "Group"
date: "11/22/2021"
output: html_document
---

```{r setup, include=FALSE}
# some of common options (and the defaults) are: 
# include=T, eval=T, echo=T, results='hide'/'asis',..., collapse=F, warning=T, message=T, error=T, cache=T, fig.width=6, fig.height=4, fig.dim=c(6,4) #inches, fig.align='left'/'center','right', 
# knitr::opts_chunk$set(warning = F, results = 'markup', message = F)
knitr::opts_chunk$set(warning = F, results = 'hide', message = F)
# knitr::opts_chunk$set(include = F)
# knitr::opts_chunk$set(echo = TRUE)
options(scientific=T, digits = 3) 
# options(scipen=9, digits = 3) 
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times
```

```{r basic, include=F}
# use this function to conveniently load libraries and work smoothly with knitting
# can add quietly=T option to the require() function
loadPkg = function(pkg, character.only = FALSE) { 
  if (!character.only) { pkg <- as.character(substitute(pkg)) }
  pkg <- ifelse(!character.only, as.character(substitute(pkg)) , pkg)  
  if (!require(pkg,character.only=T, quietly =T)) {  install.packages(substitute(pkg),dep=T); if(!require(pkg,character.only=T)) stop("Package not found") } 
}
loadPkg(knitr)

# unload/detact package when done using it
unloadPkg = function(pkg, character.only = FALSE) { 
  if(!character.only) { pkg <- as.character(substitute(pkg)) } 
  search_item <- paste("package", pkg,sep = ":") 
  while(search_item %in% search()) { detach(search_item, unload = TRUE, character.only = TRUE) } 
}

```



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyr)
data <- read.csv("Data/uk_used_cars.csv")
data<- data[!(data$year== 2060),]
data<- data[rowSums(is.na(data)) == 0,]
data<-data[!(data$year < 2008),]
data <- data[!(data$fuelType == "Electric" | data$fuelType == "Other"),]
data <- data[! (data$transmission == "Other"),]

data

```






```{r}
anovaRes = aov(price ~ Car.Make, data=data)
names(anovaRes)
summary(anovaRes)
```

```{r}
tukeyAoV <- TukeyHSD(anovaRes)
tukeyAoV

```




```{r}
library(dplyr)
data %>% 
  group_by(Car.Make) %>%
  summarise_at(vars(price), list(mean = mean))

```

```{r}
#data <- sapply(data, unclass)
df<- as.data.frame(data)
df$model <- as.factor(df$model)
df$price <- as.factor(df$price)
df$transmission <- as.factor(df$transmission)
df$fuelType <- as.factor(df$fuelType)
df$Car.Make <- as.factor(df$Car.Make)
df$price <- as.numeric(df$price)
head(df)
```

```{r}
# create correlation plot of data 
# subset categorical data and quantiative data to check for correlation between price
library(ggcorrplot)
#loadPkg(ggcorrplot)
data_new_quant <- subset(df, select = c('year','price','mileage','tax','mpg','engineSize'))
corr_quant <- round(cor(data_new_quant), 1)
p.mat_quant <- cor_pmat(corr_quant, method = 'pearson')
ggcorrplot(corr_quant, hc.order=TRUE,lab = TRUE, p.mat = p.mat_quant)+ labs(title = "Correlation Plot of Quantiative data")

# scatterplot matrix
#pairs()

```


```{r}
# categorical data correlation plot 
data_clean_cat <- subset(df, select = c('model','price','transmission','fuelType','Car.Make'))
# make categorical data numeric
data_new_cat <- sapply(data_clean_cat, unclass)
corr_cat <- round(cor(data_new_cat), 1) 
p.mat_cat <- cor_pmat(corr_cat, method = 'spearman') # use Spearman correlation for large dataset of categorical features
ggcorrplot(corr_cat, hc.order=TRUE,p.mat=p.mat_cat, lab = TRUE) + labs(title = "Correlation Plot of Categorical data")

# cor(data_new_cat$price, data_new_cat$model,
#   method = "spearman"
# )

```

# Logistic Regression

```{r}
 quantile(data$price)
```

```{r}
# Add new Price_Range variable (Dependent Variable for Logistice Regression)
data<- data %>% mutate(Price_Range =
                     case_when(
                               price <=20900 ~ "Non- Luxury",
                               price > 20900  ~ "Luxury")
)

```

```{r}
# drop model and price
drops <- c("model","price")
data<- data[ , !(names(data) %in% drops)]
data
```

```{r}
# One-hot encoding
library(mltools)
library(data.table)
data$year <- as.factor(data$year)

data_df <- as.data.frame(one_hot(as.data.table(data)))
drops <- c("transmission_Other","fuelType_Other", "fuelType_Electric", "Car.Make_Ford Focus", "Car.Make_Mercedes C Class")
data_df = data_df[ , !(names(data_df) %in% drops)]
data_df
#data_df = subset(data_df, select = -c(transmission_Other,fuelType_Other, fuelType_Electric, Car.Make_Ford Focus, Car.Make_Mercedes C Class) )
#data_df
data_df %>%
   mutate_at(c("mileage","tax", "mpg", "engineSize"), funs(c(scale(.))))
library(superml)
label <- LabelEncoder$new()
data_df$Price_Range <- label$fit_transform(data_df$Price_Range)


data_df

```


```{r}

# Logistic regression using jags
require(rjags)
require(runjags)

price_model <- "model{
  for(i in 1:N){
    y[i] ~ dbern(p[i])
    
    
    logit(p[i]) <- int + b[1] * TA[i] +b[2] * TM[i] +b[3]*TS[i]+ b[4]* Mileage[i] + b[5]*FD[i]  + b[6] * FH[i] + b[7] +FP[i] + b[8] * tax[i] + b[9]* mpg[i] + b[10] * engineSize[i] + b[11]*Y2008[i] +  b[12]*Y2009[i] + b[13]*Y2010[i] + b[14]*Y2011[i] + b[15]*Y2012[i] + b[16]*Y2013[i] + b[17]*Y2014[i] + b[18]*Y2015[i] + b[19]*Y2016[i]
    + b[20]*Y2017[i] + b[21]*Y2018[i] + b[22]*Y2019[i] + b[23]*Y2020[i] +  b[24] * Audi[i] + b[25] * BMW[i] + b[26]* Ford[i] + b[27] * Hyundai[i] + b[28] * Mercedes[i] + b[29]* Skoda[i] + b[30]* Toyota[i]+ b[31] * Vauxhall[i] + b[32] * Volkswagen[i] 
    
  
  
  }
  int ~ dnorm(0.0, 1.0/25.0)
  for (j in 1:32){
  b[j] ~ dnorm(0, 10 ^ (-2))
  }
}"
price_jags <- jags.model(textConnection(price_model), data = list(y=data_df$Price_Range, 
                                                                  Y2008=data_df$year_2008,
                                                                  Y2009=data_df$year_2009,
                                                                  Y2010=data_df$year_2010,
                                                                  Y2011=data_df$year_2011,
                                                                  Y2012=data_df$year_2012,
                                                                  Y2013=data_df$year_2013,
                                                                  Y2014=data_df$year_2014,
                                                                  Y2015=data_df$year_2015,
                                                                  Y2016=data_df$year_2016,
                                                                  Y2017=data_df$year_2017,
                                                                  Y2018=data_df$year_2018,
                                                                  Y2019=data_df$year_2019,
                                                                  Y2020=data_df$year_2020,
                                                                  Audi= data_df$Car.Make_Audi,
                                                                  BMW= data_df$Car.Make_BMW,
                                                                  Ford= data_df$Car.Make_Ford,
                                                                  Hyundai= data_df$Car.Make_Hyundai,
                                                                  Mercedes= data_df$Car.Make_Mercedes,
                                                                  Skoda= data_df$Car.Make_Skoda,
                                                                  Toyota= data_df$Car.Make_Toyota,
                                                                  Vauxhall= data_df$Car.Make_Vauxhall,
                                                                  Volkswagen= data_df$Car.Make_Volkswagen,
                                                                  TA=data_df$transmission_Automatic,
                                                                  TM= data_df$transmission_Manual,
                                                                  TS=data_df$`transmission_Semi-Auto`,
                                                                  Mileage=data_df$mileage, FD= data_df$fuelType_Diesel
                                                                  , FH= data_df$fuelType_Hybrid, 
                                                                  FP= data_df$fuelType_Petrol, 
                                                                  tax= data_df$tax, mpg= data_df$mpg, 
                                                                  engineSize= data_df$engineSize,
                                                                  N=length(data), n.chains=3,
                   n.adapt=3000))


update(price_jags,  n.iter=1000,progress.bar = 'none')
price_sim <- coda.samples(price_jags, c("int", "b"), n.iter=1000,
                        )

price_csim <- as.mcmc(do.call(rbind, price_sim))



#Results
Res <- do.call(rbind.data.frame, price_sim)

#summary(price_sim)
#pricemcmc <- data.frame(price_sim[[1]])
#head(pricemcmc, 3)

#m3 <- 1 / (1 + exp(-(pricemcmc$b0 + 3 * pricemcmc$b1)))
#plot(density(m3))
```

```{r}
# Trace and Density plots for all coefficients
plot(price_sim)
#gelman.diag(price_sim)
#autocorr.diag(price_sim)
#autocorr.plot(price_sim)
#effectiveSize(price_sim)

```
```{r}
# Summary of Coefficents mean and standard deviation
summary(price_sim)
```

```{r}
pm_coeff <- colMeans(price_csim)
pm_coeff
```


```{r}
par(mfrow= c(3,2))
densplot(price_csim[,1:6])
colnames(data_df)

```

```{r}
par(mfrow= c(3,2))
densplot(price_csim[,6:12])
colnames(data_df)


```







```{r}
par(mfrow= c(3,2))
densplot(price_csim[,12:24])
colnames(data_df)

```

```{r}
par(mfrow= c(3,2))
densplot(price_csim[,24:32])
colnames(data_df)
```






```{r}
# Generate probabilty matrix for all coefficients
X <- data.matrix(data_df[1:32])

pm_Xb <- pm_coeff["int"] + X[,c(1:32)] %*% pm_coeff[1:32]
pm_Xb

```


```{r}
# Calculate Probabilites for each record
phat <- 1 / (1 +exp(-pm_Xb))
phat
```

```{r}
plot(phat, jitter(data_df$Price_Range))
```


```{r}
# Confusion matrix and setting probability cutoff at 0.5
tab0.5 <- table(phat >0.5, data_df$Price_Range)
tab0.5
```



```{r}
# Model Accuracy 
sum(diag(tab0.5)/ sum(tab0.5))
```


